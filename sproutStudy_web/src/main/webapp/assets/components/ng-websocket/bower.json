{
  "name": "ng-websocket",
  "version": "0.2.1",
  "authors": [
    "Vincenzo (Wilk) Ferrari <wilk3ert@gmail.com>"
  ],
  "description": "AngularJS HTML5 WebSocket powerful library",
  "main": "ng-websocket.js",
  "keywords": [
    "angular",
    "angularjs",
    "websocket",
    "ng",
    "html5",
    "service",
    "provider"
  ],
  "license": "MIT",
  "ignore": [
    "**/.*",
    "node_modules",
    "bower_components",
    "test",
    "tests"
  ],
  "dependencies": {
    "angular": "~1.3.2"
  },
  "devDependencies": {
    "angular-mocks": "~1.3.2"
  },
  "gitHead": "df74ffd1c2cdeb2cd14bf2fea157d1c15d9e5c0d",
  "readme": "ng-websocket\n============\n\n**AngularJS HTML5 WebSocket** powerful wrapper module to develop with ease and fun!\n\n# Index\n\n  - [Introduction](#introduction)\n  - [Requirements](#requirements)\n  - [Installation](#installation)\n  - [Usage](#usage)\n  - [Tutorial](#tutorial)\n  - [Features](#features)\n    - [Lazy Initialization](#lazy)\n    - [Auto Reconnection](#reconnect)\n    - [Enqueue Unsent Messages](#enqueue)\n    - [Mock Websocket Server](#mock)\n  - [Testing](#testing)\n  - [API](#api)\n    - [$websocketProvider](#websocketProvider)\n      - [$setup](#setup)\n    - [$websocket](#websocket)\n      - [$new](#new)\n      - [$get](#get)\n    - [ngWebsocket](#ngWebsocket)\n      - [Constructor](#constructor)\n      - [Constants](#constants)\n      - [Events](#events)\n      - [$on](#on)\n      - [$un](#un)\n      - [$emit](#emit)\n      - [$open](#open)\n      - [$close](#close)\n      - [$status](#status)\n      - [$ready](#ready)\n      - [$mockup](#mockup)\n    - [$$mockWebsocket](#mockWebsocket)\n  - [Contribute](#contribute)\n  - [License](#license)\n\n# Introduction\n\n**ngWebsocket** is a library that provides a provider and a service to handle **HTML5 WebSocket** with ease\nin pure **AngularJS** style!\nThe idea behind this module is to give four kinds of object to handle websockets:\n\n  - **$websocketProvider**: the provider is on top of usage. In fact, you can setup a general configuration for each ngWebsocket you're going to create\n  - **$websocket**: following an Angular service that lets you to handle different websocket instance among your application\n  - **ngWebsocket**: an instance of the HTML5 WebSocket wrapper (this is actually the core of this module): it provides lots of feature to work with websockets\n  - **$$mockWebsocket**: this is a smart implementation of a websocket backend that lets you to developer and test your app without a real responding server\n\nFor each of these objects an API is available and fully documented in this document.\n\n# Requirements\n\nThe only requirement needed is [AngularJS](https://angularjs.org/) that you can install it via [Bower](http://bower.io/).\n\n# Installation\n\nUse [Bower](http://bower.io/) to install this module:\n\n```bash\n$ bower install ng-websocket\n```\n\nOr simply `git clone` the repo and install the dependencies with [NPM](https://www.npmjs.org/):\n\n```bash\n$ git clone https://github.com/wilk/ngWebsocket\n$ cd ngWebsocket\n$ npm install\n```\n\n# Usage\n\nAfter the [Installation](#installation), require it in your Angular application.\n\nFirstly, in your `index.html`:\n\n```html\n<html>\n    <head>\n        <script src=\"bower_components/ng-websocket/ng-websocket.js\"></script>\n    </head>\n</html>\n```\n\nThen, in your Angular application definition (assumed `app.js`):\n\n```javascript\n    'use strict';\n\n    angular.module('MyApp', ['ngWebsocket']);\n```\n\nNow, you're ready to use it!\n\n# Tutorial\n\nNeed to use HTML5 WebSocket to build your cool web application, huh?\nNo problem, dude! Check this out!\n\n```javascript\n'use strict';\n\nangular.module('MyCoolWebApp', ['ngWebsocket'])\n    .run(function ($websocket) {\n        var ws = $websocket.$new('ws://localhost:12345'); // instance of ngWebsocket, handled by $websocket service\n\n        ws.$on('$open', function () {\n            console.log('Oh my gosh, websocket is really open! Fukken awesome!');\n\n            ws.$emit('ping', 'hi listening websocket server'); // send a message to the websocket server\n\n            var data = {\n                level: 1,\n                text: 'ngWebsocket rocks!',\n                array: ['one', 'two', 'three'],\n                nested: {\n                    level: 2,\n                    deeper: [{\n                        hell: 'yeah'\n                    }, {\n                        so: 'good'\n                    }]\n                }\n            };\n\n            ws.$emit('pong', data);\n        });\n\n        ws.$on('pong', function (data) {\n            console.log('The websocket server has sent the following data:');\n            console.log(data);\n\n            ws.$close();\n        });\n\n        ws.$on('$close', function () {\n            console.log('Noooooooooou, I want to have more fun with ngWebsocket, damn it!');\n        });\n    });\n```\n\nEasy, right?\n\nWell, let's chain it!\n\n```javascript\n'use strict';\n\nangular.module('MyCoolChainedWebApp', ['ngWebsocket'])\n    .run(function ($websocket) {\n        var ws = $websocket.$new('ws://localhost:12345')\n          .$on('$open', function () {\n            console.log('Oh my gosh, websocket is really open! Fukken awesome!');\n\n            var data = {\n                level: 1,\n                text: 'ngWebsocket rocks!',\n                array: ['one', 'two', 'three'],\n                nested: {\n                    level: 2,\n                    deeper: [{\n                        hell: 'yeah'\n                    }, {\n                        so: 'good'\n                    }]\n                }\n            };\n\n            ws.$emit('ping', 'hi listening websocket server') // send a message to the websocket server\n              .$emit('pong', data);\n          })\n          .$on('pong', function (data) {\n            console.log('The websocket server has sent the following data:');\n            console.log(data);\n\n            ws.$close();\n          })\n          .$on('$close', function () {\n            console.log('Noooooooooou, I want to have more fun with ngWebsocket, damn it!');\n          });\n    });\n```\n\nYour back-end team is lazy? No problem: we can do it on our own!\n\n```javascript\n'use strict';\n\nangular.module('MyIndipendentCoolWebApp', ['ngWebsocket'])\n    .run(function ($websocket) {\n        var ws = $websocket.$new({\n            url: 'ws://localhost:12345',\n            mock: {\n                fixtures: {\n                    'custom event': {\n                        data: 'websocket server mocked response'\n                    },\n                    'another event': {\n                        data: {\n                            damn: 'dude',\n                            that: 'is awesome!'\n                        }\n                    }\n                }\n            }\n        });\n\n        ws.$on('$open', function () {\n            ws.$emit('an event', 'a parrot response') // by default it responde with the same incoming data\n              .$emit('custom event') // otherwise it uses the given fixtures\n              .$emit('another event'); // even for objects\n          })\n          .$on('an event', function (message) {\n            console.log(message); // it prints 'a parrot response'\n          })\n          .$on('custom event', function (message) {\n            console.log(message); // it prints 'websocket server mocked response'\n          })\n          .$on('another event', function (message) {\n            console.log(message); // it prints the object {damn: 'dude', that: 'is awesome!'}\n          });\n    });\n```\n\n# Features\n\nngWebsocket comes from Italy with lots of interesting stuff, folks!\nWhy not just a wrapper? Because we can do more with happiness and fun!\n\nSo, let's discover the awesome features list!\n\n## Lazy\n\nUsing basic HTML5 WebSocket object, you experienced that the connection is open immediately, just after the websocket is created with **new** constructor.\nBy default, the same behaviour is used by ngWebsocket but you can simply change it with this powerful feature:\n\n```javascript\nangular.run(function ($websocket, $timeout) {\n    var ws = $websocket.$new({\n        url: 'ws://localhost:12345',\n        lazy: true\n    });\n\n    ws.$on('$open', function () {\n        console.log('The ngWebsocket has open!'); // It will print after 5 (or more) seconds\n    });\n\n    $timeout(function () {\n        ws.$open(); // Open the connction only at this point. It will fire the '$open' event\n    }, 5000);\n});\n```\n\nWith [$websocket.$open](#open) function, you can open the connection when you want, especially after the coffee break.\n\n**Default: disabled**\n\n## Reconnect\n\nOk, your websocket connection went down due to a bad wifi connection and you don't want to make another connection\nmanually, right?\nSo, what about an automated feature that do this for you?\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new({\n        url: 'ws://localhost:12345',\n        reconnect: true // it will reconnect after 2 seconds\n    });\n\n    ws.$on('$open', function () {\n        console.log('Here we are and I\\'m pretty sure to get back here for another time at least!');\n      })\n      .$on('$close', function () {\n        console.log('Got close, damn you silly wifi!');\n      });\n});\n```\n\nWith this feature, if the connection goes down, it will open again after 2 seconds by default.\nIf you need to get the connection back in fewer time, just use the **reconnectInterval** time slice:\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new({\n        url: 'ws://localhost:12345',\n        reconnect: true,\n        reconnectInterval: 500 // it will reconnect after 0.5 seconds\n    });\n\n    ws.$on('$open', function () {\n        console.log('Here we are and I\\'m pretty sure to get back here for another time at least!');\n      })\n      .$on('$close', function () {\n        console.log('Got close, damn you silly wifi!');\n      });\n});\n```\n\n**Pay attention, good sir**: if you close the ngWebsocket with the [**$close**](#close) method, it won't get the connection back\nuntil the [**$open**](#open) is invoked!\n\n**Default: enabled**\n\n## Enqueue\n\nFrom great powers come great responsability. Keep this in mind while reading this feature.\n\nSometimes, it would be useful if someone save our websocket communication, especially when the connection is down.\nWith this powerful feature, it's possible to store every unsent message in a queue and then flush them just the connection get up again.\n\nHow? Enabling enqueue feature, of course!\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new({\n        url: 'ws://localhost:12345',\n        lazy: true,\n        enqueue: true\n    });\n\n    ws.$emit('dude event', 'hi dude!'); // this message couldn't be forwarded because of the lazy property (the websocket is still closed)\n\n    ws.$on('$open', function () {\n        console.log('I\\'m sure the above message gets sent before this log is printed in the console ;)');\n    });\n\n    ws.$open(); // when the websocket gets open, flushes every message stored in the internal queue\n});\n```\n\n**BUT** this means that each message is stored into a memory queue and it can get really big, especially if your application sends many messages in a short time slice.\n\n**Default: disabled**\n\n## Mock\n\nDulcis in fundo, a websocket server implementation to use and test your application, without a real websocket server listening!\nYep, you well heard!\n\nThink about this situation: you're developing the front-end part of your company application and the backend team is lazy (because every developer is lazy),\nso you couldn't start writing your section because you need to send/retrieve data to/from the server.\n\nNo problem, you can!\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new({\n        url: 'ws://localhost:12345',\n        mock: true\n    });\n\n    ws.$on('$open', function () {\n        ws.$emit('hi', 'dude');\n      })\n      .$on('hi', function (message) {\n        console.log(message); // it prints 'dude'\n      });\n});\n```\n\nBy default, the mock feature simulate a parrot websocket server: this means that every message sent with\na certain event, will have a response with the same structure, with the same event and the same data.\n\nHowever, you can setup some fixtures that simulate what your lazy back-end team is going to do after beer time:\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new({\n        url: 'ws://localhost:12345',\n        mock: {\n            fixtures: {\n                hi: {\n                    data: 'dude, this is a custom message!'\n                }\n            }\n        }\n    });\n\n    ws.$on('$open', function () {\n        ws.$emit('hi');\n      })\n      .$on('hi', function (message) {\n        console.log(message); // it prints 'dude, this is a custom message'\n      });\n});\n```\n\n**Default: disabled**\n\n# Testing\n\nThis module uses [Karma](http://karma-runner.github.io/0.12/index.html) with [Jasmine](http://jasmine.github.io/) for unit testing, so before launching any test check out if all dependencies are correctly installed:\n\n```bash\n$ npm install\n```\n\nAfter that, launch the test:\n\n```bash\n$ npm test\n```\n\n# API\n\nngWebsocket APIs are composed by four different modules:\n\n - **$websocketProvider**\n - **$websocket**\n - **ngWebsocket**\n - **$$mockWebsocket** (private but configurable)\n\n## $websocketProvider\n\nFollowing the API of ngWebsocket Provider\n\n### $setup\n\nIf you need to setup your custom default configuration for each ngWebsocket istance, pass it to this method:\n\n```javascript\nangular.config(function ($websocketProvider) {\n    $websocketProvider.$setup({\n        lazy: false,\n        reconnect: true,\n        reconnectInterval: 2000,\n        mock: false,\n        enqueue: false\n    });\n});\n```\n\n**Usage**\n\n```javascript\n$setup(config)\n```\n\n**Arguments**\n\n| **Param** | **Type** | **Details** |\n| --------- | -------- | ----------- |\n| config    | Object   | default ngWebsocket configuration |\n\n**Returns**\n\n| **Type** | **Details** |\n| -------- | ----------- |\n| $websocketProvider | the $websocketProvider |\n\n## $websocket\n\nFollowing the API of the $websocket Service\n\n### $get\n\nEvery ngWebsocket instance created with [$websocket.$new](#new) method are stored within the $websocket service.\nTo get one of them, you can use **$get** with the url of the websocket you're looking for:\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$get('ws://localhost:12345');\n});\n```\n\nThe url is needed because it is stored using the url as the key of an hashmap.\n\n**Usage**\n\n```javascript\n$get(url)\n```\n\n**Arguments**\n\n| **Param** | **Type** | **Details** |\n| --------- | -------- | ----------- |\n| url       | String   | the websocket url |\n\n**Returns**\n\n| **Type** | **Details** |\n| -------- | ----------- |\n| ngWebsocket | an instance of ngWebsocket or undefined |\n\n### $new\n\nThere are two ways to create a new instance of ngWebsocket:\n\n**string (url)**\n\nThe url is always needed and it has to start with the websocket schema (ws:// or wss://):\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new('ws://localhost:12345');\n});\n```\n\nA new instance is returned and the internal WebSocket has already started the connection with the websocket server on the backend.\n\n**object**\n\nAll of the following configurations can be changed:\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new(\n        url: 'ws://localhost:12345',\n        lazy: false,\n        reconnect: true,\n        reconnectInterval: 2000,\n        mock: false,\n        enqueue: false\n    );\n});\n```\n\nFor more information see the [ngWebsocket Constructor section](#constructor).\n\n**Usage**\n\n```javascript\n$new(url|config)\n```\n\n**Arguments**\n\n| **Param** | **Type** | **Details** |\n| --------- | -------- | ----------- |\n| url/config | String/Object | websocket url or a configuration set |\n\n**Returns**\n\n| **Type** | **Details** |\n| -------- | ----------- |\n| ngWebsocket | an instance of ngWebsocket |\n\n## ngWebsocket\n\nngWebsocket is the core of this module.\nIn a few words, it's a wrapper for the HTML5 WebSocket object, extending it with different features.\nIt acts like an EventEmitter and it provides a common way to attach a handler for each fired event.\n\nFollowing the API in detail.\n\n### Constructor\n\nThe constructor of the ngWebsocket accepts two kind of parameters:\n\n  - String: the url starting with the WebSocket schema (ws:// or wss://)\n  plus an optional String/String[] containing the protocols (this matches\n  the WebSocket constructor API)\n  - Object: a configuration containing the websocket url\n\nThe url is a requirement to create a new ngWebsocket.\nAn instance is always created with a factory method by the [$websocket](#websocket) service: in fact,\nit lets to make different websockets that are pointing to different urls.\n\nExample of a basic instantiation:\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new('ws://localhost:12345', ['binary', 'base64']);\n});\n```\n\nUsing Object configuration:\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new({\n        url: 'ws://localhost:12345',\n        lazy: false,\n        reconnect: true,\n        reconnectInterval: 2000,\n        enqueue: false,\n        mock: false,\n        protocols: ['binary', 'base64']\n    });\n});\n```\n\nFollowing the explanation of the configuration object - {Type} PropertyName (default):\n\n  - **{Boolean} lazy (false)**: lazy initialization. A websocket can open the connection when ngWebsocket is instantiated with [$websocket.$new](#new) (false) or afterwards with [$open](#open) (false). For more information see [Features - Lazy Initialization](#lazy)\n  - **{Boolean} reconnect (true)**: auto reconnect behaviour. A websocket can try to reopen the connection when is down (true) or stay closed (false). For more information see [Features - Auto Reconnect](#reconnect)\n  - **{Number} reconnectInterval (2000)**: auto reconnect interval. By default, a websocket try to reconnect after 2000 ms (2 seconds). For more information see [Features - Auto Reconnect](#reconnect)\n  - **{Boolean} enqueue (false)**: enqueue unsent messages. By default, a websocket discards messages when the connection is closed (false) but it can enqueue them and send afterwards the connection gets open back (true). For more information see [Features - Enqueue Unsent Messages](#enqueue)\n  - **{Boolean/Object} mock (false)**: mock a websocket server. By default, a websocket run only if the webserver socket is listening (false) but it can be useful to mock the backend to make the websocket working (true). For more information see [Features - Mock Websocket Server](#mock)\n  - **{String/String[]} (null)**: Either a single protocol string or an array of protocol strings. This is the same as the WebSocket protocols argument.\n\n### Constants\n\nWebsocket status constants:\n\n  - **$CONNECTING**: the websocket is trying to open the connection\n  - **$OPEN**: the websocket connection is open\n  - **$CLOSING**: the websocket connection is closing\n  - **$CLOSED**: the websocket connection is closed\n\n### Events\n\nThere are custom events fired by ngWebsocket.\nThey are useful to setup a listener for certain situations and behaviours:\n\n  - **$open**: the websocket gets open\n  - **$close**: the websocket gets closed\n  - **$error**: an error occurred (callback params: {Error} error)\n  - **$message**: the original message sent from the server (callback params: {String} message). Usually, it's a JSON encoded string containing the event to fire and the data to pass ({\"event\": \"an event\", \"data\": \"some data\"})\n\nThe other events are custom events, setup by the user itself.\n\n### $on\n\nAttach one or more handlers to a specific event.\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new('ws://localhost:12345');\n\n    // Single event handler\n    ws.$on('my event', function myHandler () {...});\n\n    // Different event handlers\n    ws.$on('another event', myHandler, mySecondHandler, myThirdHandler);\n\n    // Different chained event handlers\n    ws.$on('third event', function myHandler () {...})\n      .$on('third event', function mySecondHandler () {...})\n      .$on('third event', function myThirdHandler () {...});\n});\n```\n\nNow the websocket is listening for 'my event' event and the handler 'myHandler' will be called when that event\nis sent by the websocket server. The same thing happens for the other two cases: each event handler is called\none by one, starting from the first one, ending with the last one.\n\n**Usage**\n\n```javascript\n$on(event, handler|handlers)\n```\n\n**Arguments**\n\n| **Param** | **Type** | **Details** |\n| --------- | -------- | ----------- |\n| event | String | the event to attach a listener |\n| handler/handlers | Function/Function[] | one or more handlers to invoke when the event is fired up |\n\n**Returns**\n\n| **Type** | **Details** |\n| -------- | ----------- |\n| ngWebsocket | the ngWebsocket |\n\n### $un\n\nDetach a handler from a specific event.\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new('ws://localhost:12345');\n\n    ws.$on('my event', function myHandler () {...});\n    ws.$un('my event');\n});\n```\n\nThe above websocket has not listener attached at the end of the execution.\n\n\n**Usage**\n\n```javascript\n$un(event)\n```\n\n**Arguments**\n\n| **Param** | **Type** | **Details** |\n| --------- | -------- | ----------- |\n| event     | String   | the event to detach the listener |\n\n**Returns**\n\n| **Type** | **Details** |\n| -------- | ----------- |\n| ngWebsocket | the ngWebsocket |\n\n### $emit\n\nSend an event to the websocket server.\n\nIt's possible to send a lonely event or attaching some data to it.\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new('ws://localhost:12345');\n\n    ws.$on('$open', function () {\n        ws.$emit('lonely event'); // the websocket server will receive only the event name\n        ws.$emit('event with data', 'some data'); // it will send the event with 'some data' string\n        ws.$emit('with object', {some: 'data'}); // it will send the event with the object JSONified\n    });\n});\n```\n\nIt's possible to send both simply (like strings and numbers) and complex data (like objects and arrays).\n\n**Usage**\n\n```javascript\n$emit(event, [data])\n```\n\n**Arguments**\n\n| **Param** | **Type** | **Details** |\n| --------- | -------- | ----------- |\n| event     | String   | the event to send |\n| data (optional) | String/Number/Object | the data to send with the event |\n\n**Returns**\n\n| **Type** | **Details** |\n| -------- | ----------- |\n| ngWebsocket | the ngWebsocket |\n\n### $open\n\nOpen the websocket connection if it's closed.\n\n```javascript\nangular.run(function ($websocket, $timeout) {\n    var ws = $websocket.$new({\n        url: 'ws://localhost:12345',\n        lazy: true\n    });\n\n    ws.$on('$open', function () {\n        console.log('The websocket now is open');\n    });\n\n    $timeout(function () {\n        ws.$open(); // it will open the websocket after 5 seconds\n    }, 5000);\n```\n\n**Usage**\n\n```javascript\n$open()\n```\n\n**Returns**\n\n| **Type** | **Details** |\n| -------- | ----------- |\n| ngWebsocket | the ngWebsocket |\n\n### $close\n\nIt closes the websocket connection if it's open.\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new(url: 'ws://localhost:12345');\n\n    ws.$on('$open', function () {\n        ws.$close(); // it closes the websocket connection\n    });\n\n    ws.$on('$close', function () {\n        console.log('Connection closed!');\n    });\n```\n\n**Usage**\n\n```javascript\n$close()\n```\n\n**Returns**\n\n| **Type** | **Details** |\n| -------- | ----------- |\n| ngWebsocket | the ngWebsocket |\n\n### $status\n\nIt returns the current status of the websocket connection.\nIt's possible to use the [websocket constants](#constants) to make checks.\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new(url: 'ws://localhost:12345');\n\n    console.log(ws.$status()); // it prints ws.$CONNECTING\n\n    ws.$on('$open', function () {\n        console.log(ws.$status()); // it prints ws.$OPEN\n        ws.$close(); // it closes the websocket connection\n        console.log(ws.$status()); // it prints ws.$CLOSING\n    });\n\n    ws.$on('$close', function () {\n        console.log(ws.$status()); // it prints ws.$CLOSED\n        console.log('Connection closed!');\n    });\n```\n\n**Usage**\n\n```javascript\n$status()\n```\n\n**Returns**\n\n| **Type** | **Details** |\n| -------- | ----------- |\n| Number   | a constant number representing the websocket connection readyState |\n\n### $ready\n\nIt returns if the websocket connection is open or closed.\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new(url: 'ws://localhost:12345');\n\n    console.log(ws.$ready()); // it prints false\n\n    ws.$on('$open', function () {\n        console.log(ws.$ready()); // it prints true\n        ws.$close(); // it closes the websocket connection\n        console.log(ws.$ready()); // it prints false\n    });\n\n    ws.$on('$close', function () {\n        console.log(ws.$ready()); // it prints false\n        console.log('Connection closed!');\n    });\n```\n\n**Usage**\n\n```javascript\n$ready()\n```\n\n**Returns**\n\n| **Type** | **Details** |\n| -------- | ----------- |\n| Boolean  | true if the connection is OPEN, false otherwise |\n\n### $mockup\n\nIt returns if the websocket is mocked up or not.\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new(url: 'ws://localhost:12345');\n\n    console.log(ws.$mockup()); // it prints false\n\n    var ws2 = $websocket.$new({\n        url: 'ws://localhost:54321',\n        mock: true\n    });\n\n    console.log(ws.$mockup()); // it prints true\n```\n\n**Usage**\n\n```javascript\n$mockup()\n```\n\n**Returns**\n\n| **Type** | **Details** |\n| -------- | ----------- |\n| Boolean  | true if the ngWebsocket istance is mocked up, false otherwise |\n\n## $$mockWebsocket\n\nIf you need to develop or test your application without a real websocket backend server, you can setup\na mockup of it with this feature.\nThe only thing to do is to pass a configuration object during the ngWebsocket initialization:\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new({\n        url: 'ws://localhost:12345',\n        mock: {\n            openTimeout: 500,\n            closeTimeout: 1000,\n            messageInterval: 2000,\n            fixtures: {}\n        }\n    });\n```\n\nFollowing the explanation of the configuration object - {Type} PropertyName (default)::\n\n  - **{Boolean/Object} mock (false)**: could be either a Boolean (default to false) or an object\n  - **{Number} openTimeout (500)**: timeout to make the internal websocket to get open\n  - **{Number} closeTimeout (1000)**: timeout to make the internal websocket to get closed\n  - **{Number} messageInterval (2000)**: the internal websocket sends enqueued message with this interval time\n  - **{Object/String} fixtures ({})**: an object of fixtures, where the keys are the events and the values are the data to respond, or an url to retrieve remote fixtures via HTTP\n\nFixtures can mock both custom events and data.\nThey can be added as a static object with the following structure:\n\n```javascript\nfixtures: {\n    'incoming event name': {\n        event: 'outgoing event name',\n        data: 'response data'\n    }\n}\n```\n\nThe *incoming event name* is the event fired by the websocket while the *outgoing event name* is the one sent by the mocked webserver.\nSo, it be useful to map events with a custom response.\nBy default, the mock feature acts like a parrot server, responding with the same data on the same received event.\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new({\n        url: 'ws://localhost:12345',\n        mock: {\n            fixtures: {\n                'mock data': {\n                    data: {\n                        hello: 'world'\n                    }\n                },\n                'mock data and event': {\n                    event: 'custom event',\n                    data: {\n                        hello: 'mocked world'\n                    }\n                }\n            }\n        }\n    });\n\n    ws.$on('$open', function () {\n        ws.$emit('parrot event', 'parrot data')\n          .$emit('mock data')\n          .$emit('mock data and event');\n      })\n      .$on('parrot event', function (message) {\n        console.log(message); // it prints 'parrot data'\n      })\n      .$on('mock data', function (message) {\n        console.log(message); // it prints '{hello: 'world'}'\n      })\n      .$on('custom event', function (message) {\n        console.log(message); // it prints '{hello: 'mocked world'}'\n      });\n```\n\nFixtures can be loaded through an HTTP request.\nIn fact, it be useful to have those in a JSON file or created by the webserver:\n\n```javascript\nangular.run(function ($websocket) {\n    var ws = $websocket.$new({\n            url: 'ws://localhost:12345',\n            mock: {\n                fixtures: '/fixtures.json' // fixtures are located in a file or calculated at run-time by the web server\n            }\n        });\n    \n    // Now you're ready to use fixtures because the websocket will be available only when the fixtures are loaded\n});\n```\n\n# Contribute\n\nWanna contribute, fella?\nThat's the right place to find useful information!\n\nHow?\n\n  - improve and fix the documentation\n  - test it\n  - make some demos\n  - use it\n  - write new pieces of code\n  - optimize it\n  - find bugs\n\nAnd don't forget to make **pull requests**, damn it!\n\n# License\n\nCheck out LICENSE file (MIT)",
  "readmeFilename": "README.md",
  "_id": "ng-websocket@0.2.1",
  "repository": {
    "type": "git",
    "url": "git://github.com/wilk/ng-websocket.git"
  }
}